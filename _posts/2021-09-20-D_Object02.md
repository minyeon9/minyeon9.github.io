---
layout: single
title: "객체(Object) - 생성자(Constructor) / 메서드(Method)"
catigories: ['Programming', 'Java']
---
   
#### 생성자(Constructor)
* 객체 안에서 만들어지는 필드 초기화 + 생성 시 필요한 기능 수행
* 일종의 메서드로 전달된 초기 값을 받아서 객체의 필드에 기록
* 반환 값 없음
* 생성자 명은 클래스 명과 동일하게 지정   
``` java
[접근제한자] [예약어] class 클래스명 {
    [접근제한자] 클래스명() { }
    [접근제한자] 클래스명(매개변수) { (this.)필드명 = 매개변수; }
}

public class Academy {
    private int studentNo;
    private String name;

    public Academy() {} // 기본 생성자
    public Academy(int studentNo, String name) { //매개변수 있는 생성자
        this.studentNo = studentNo;
        this.name = name;
    }
    // Academy = 동일한 이름 사용
}
```   
   
1) 기본생성자
* 작성하지 않는 경우 클래스 사용 시 JVM이 자동으로 기본 생성자를 생성   

2) 매개 변수 생성자
* 객체 생성 시 전달 받은 값으로 객체를 초기화
* 매개변수 생성자 삭정 시 JVM이 기본 생성자를 자동으로 생성하지 않음
* 상속에서 사용 시 반드시 기본 생상자를 작성
* 오버로딩 이용하여 작성
   
3) 오버로딩
* 한 클래스 내에 동일한 이름의 메서드를 사용
* 조건
    * 동일한 메서드 이름
    * 다른 매개변수의 개수 또는 다른 매개변수 타입   
![Alt text](assets/images/overloading01.png)   
여기서 오류가 나는 이유는 매개변수의 개수와 자료형이 동일하기 때문이다.   
같은 자료형에 매개변수명만 다르게 지정하는 건 오버로딩에 영향을 주지 않는다.   
   
![Alt text](assets/images/overloading02.png)   
3번째와 5번째 매개변수의 개수는 동일하지만 자료형이 상이하기 때문에 가능하다.   
또, 3번째와 4번째에 동일한 매개변수의 이름이 선언되었지만 개수가 다르기 때문에 가능한 걸 볼 수 있다.   
   
***
#### 메서드(Method)
* 수학의 함수와 비슷
* 호출을 통해 사용
* 전달값이 없는 상태로 호출하거나 어떤 값을 전달하여 호출
* 함수 내에 작성된 연산 수행
* 수행 후 반환 값과 결과 값은 없을 수도 있음   
``` java
[접근제한자] [예약어] 반환형 메소드명( [매개변수] ) { // 메서드 시그니처
    // 기능 정의
}

public void information() {
    System.out.println(studentNo);
}
```   
   
1) 메서드 예약어
|구분|설명|
|------|---|
|static|static 영역에 할당하여 객체 생성 없이 사용|
|final|종단의 의미, 상속 시 오버라이딩 불가능|
|abstract|미완성된, 상속하여 오버라이딩으로 완성시켜 사용해야 함|
|synchronized|동기화 처리, 공유 자원에 한 개의 스레드만 접근 가능|
|static final(final static)|static과 final의 의미를 둘 다 가짐|   
   
2) 메서드 반환형
|구분|설명|
|------|---|
|void|반환형이 없음을 의미, 반환 값이 없을 경우 반드시 작성|
|기본 자료형|연산 수행 후 변환 값이 기본 자료형일 경우 사용|
|배열|연산 수행 후 반환 값이 배열인 경우 배열의 주소값이 반환|
|클래스|연산 수행 후 반환 값이 해당 클래스 타입의 객체일 경우   해당 객체의 주소값이 반환(클래스 == 타입)|   
   
3) 매개변수
|구분|설명|
|------|---|
|()|매개변수가 없는 것을 의미|
|기본 자료형|기본형 매개변수 사용 시 값을 복사하여 전달   매개변수 값을 변경해도 본래 값은 변경되지 않음|
|배열|배열, 클래스 등 참조형을 매개변수로 전달 시에는 데이터의 주소 값을   전달하기 때문에 매개변수를 수정하면 본래의 데이터가 수정됨(얕은 복사)|
|클래스|''|
|가변인자|매개변수의 개수를 유동적으로 설정하는 방법   가변 매개변수 외 다른 매개변수가 있으면 가변 매개변수를 마지막에 설정|   
   
4) 메서드 접근제한자
|구분||설명|클래스|패키지|자식 클래스|전체
|------|---|---|---|---|---|
|+|public|O|O|O|O|
|#|protected|O|O|O||
|~|(default)|O|O||| 	 
|-|private|O||||   
   
***   
#### getter / setter 메서드
1) getter
* 필드에 정의된 값을 요청한 쪽으로 넘겨주는 메서드   
``` java
[접근제한자] [예약어] 반환형 get필드명() {
    return 필드명;
}

public int getStudentNo() {
    return studentNo;
}
```   
   
2) setter
* 필드 값을 변경하는 메서드
``` java
[접근제한자] [예약어] void set필드명(자료형 변수명) {
    (this.)필드명 = 자료형 변수명;
}

public void setStudentNo(int studentNo) {
    this.studentNo = studentNo;
}
```   
   
***
여태까지는 반환값이 없는 메서드를 만들고,   
메인 메서드로 호출해서 사용하는 방식으로 실습을 진행했었다.   

여기에   
필드, 생성자, 메서드가 생기고.. 거기에 막 자료형 갖다 붙이고.......... 접근제한자까지 생기니까 머리가 지끈..   

내일은 시험 보는 날..!   
   
***